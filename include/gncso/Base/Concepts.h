#pragma once

#include <functional>
#include <limits>
#include <vector>

#include "BaseConcepts.h"


namespace gncso {


  /** A lightweight struct containing a set of basic configuration parameters
   * for the GNC */
template <typename Scalar = double>
struct GNCParams
{
      /* minimum number of *points* for the variable estimation*/
      size_t nr_min_points;
      /** A limit on the total number of outer iterations to perform */
      size_t max_outer_iterations;

      /** A limit on the total number of inner iterations to perform  */
      size_t max_inner_iterations;

      /** Threshold for the difference between the previos cost value and the actual */
      Scalar cost_diff_threshold;

      Scalar mu_threshold;

      Scalar max_res_tol_sq;

      /** Threshold for the detection of inliers: if weight(k) > threshold, k is an inlier */
      Scalar inliers_threshold;

      /** Factor for the update-mu step */
      Scalar gnc_factor;

      /** A limit on the total permissible elapsed computation time (in seconds) */
      Scalar max_computation_time;

      /** A Boolean flag indicating whether to store and return the sequence of
       * iterates generated by the optimization algorithm as it runs */
      bool GNClog_iterates;

      bool log_outer_iters;

      /** A Boolean flag indicating whether the optimization method should print
       * information to stdout as it runs */
      size_t GNC_verbose;

      /** Decimal precision for real-valued variables in printed output */
      size_t precision;


      GNCParams(size_t nr_min_points=1, size_t max_outer_iterations = 1000, size_t max_inner_iterations = 1,
         double cost_diff_threshold = 0.0001, double mu_threshold = 0.0001, double max_res_tol_sq = 0.0004,
         double inliers_threshold = 0.8, double gnc_factor = 1.5, double max_computation_time = std::numeric_limits<double>::max(),
         bool GNClog_iterates = false, bool log_outer_iters = false, size_t GNC_verbose = false, size_t precision = 3,
         double factor_ref_res = 1.2):
         nr_min_points(nr_min_points), max_outer_iterations(max_outer_iterations), max_inner_iterations(max_inner_iterations),
         cost_diff_threshold(cost_diff_threshold), mu_threshold(mu_threshold), max_res_tol_sq(max_res_tol_sq),
         inliers_threshold(inliers_threshold), gnc_factor(gnc_factor), max_computation_time(max_computation_time),
         GNClog_iterates(GNClog_iterates), log_outer_iters(log_outer_iters), GNC_verbose(GNC_verbose),
         precision(precision){};
};  // end of struct GNCParams

enum class GNCOuterStatus{
  CONVERGENCE_COST,

  MAX_NR_ITERS
};  // End of enum

/** A basic templated struct used to capture the output of an outer iteration of GNC */
template <typename Variable, typename Weights, typename Scalar = double> struct GNCOuterResult {

  /** Final estimation **/
  /** The estimated minimizer */
  Variable x;

  /** The estimated optimal value */
  Scalar f;

  /* Final weights for this outer iteration*/
  Weights weights;

  Scalar mu;

  Scalar diff_costs;
  /** The elapsed computation time */
  double elapsed_time;

  GNCOuterStatus GNCouterstatus;

  Scalar nr_inner_iterations;  // THis vale gives the size of the next vectors!!

  /** Sequences of estimations **/
  /** The sequence of objective values at the *start* of each iteration */
  std::vector<Scalar> objective_values;

  /** The total elapsed computation time at the *start* of each iteration (in
   * seconds) */
  std::vector<double> time_inner_iter;

  /** A container to hold the sequence of iterates generated by an optimization
   * algorithm as it runs.  Note that this container is only filled in upon
   * request (by setting the 'log_iterates' field of OptimizerParams to 'true'),
   * since it may consume nontrivial amounts of memory if Variable is a complex
   * data type. */
  std::vector<Variable> iterates_x;

  std::vector<Scalar> diff_costs_updates;

  GNCOuterResult () {};

};


enum class GNCStatus
{
  MU_ZERO,

  CONVERGENCE_COST,

  ITERATION_LIMIT,

  ELAPSED_TIME,

  USER_FUNCTION   
};

template <typename Variable, typename Weights, typename Scalar = double> struct GNCResult
{
  GNCStatus GNCstatus;
  // Final items
  Variable x;

  /** The estimated optimal value */
  Scalar f;

  /* Final weights for this outer iteration*/
  Weights weights;

  Weights set_inliers;

  Scalar mu;

  /** The elapsed computation time */
  double elapsed_time;

  Scalar nr_outer_iterations;

  std::vector<GNCOuterResult<Variable, Weights, Scalar>> intermediate_outer_results;

  bool valid_estimation; 
  
  GNCResult() {};
};

///////////////////////////////////////////////

/* Initialization */
/** An alias template for a std::function that accepts as input an argument of
 * type Variable, and returns the initialization pof mu. */
template <typename Weights, typename Scalar = double, typename... Args>
using InitializationMu = std::function<Scalar(const Weights& residuals, const GNCParams<Scalar> & params, Args &... args)>;

  /* Update weights */
  template <typename Variable, typename Scalar, typename Weights, typename... Args>
  using UpdateWeights = std::function<Weights(const Variable &X, const Weights& prev_weights,
                                const Weights& residuals, const Scalar& mu, const GNCParams<Scalar> & params, Args &... args)>;

  /* Update mu */
  template <typename Scalar = double, typename... Args>
  using UpdateMu = std::function<Scalar(const Scalar& prev_mu, const GNCParams<Scalar> & params, Args &... args)>;

  /* Update mu */
  template <typename Scalar = double, typename... Args>
  using UpdateMuInner = std::function<Scalar(const Scalar& prev_mu, const Scalar& id_inner, const GNCParams<Scalar> & params, Args &... args)>;
  
  
 

} // namespace gncso
